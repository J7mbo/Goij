package TypeRegistry

import (
	"fmt"
	"math/rand"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

/* Basically writing my own template because I haven't been bothered to learn the template package yet. */
var (
	fileTop = "package main\n"

	fileImports = "import \"github.com/j7mbo/goij/src/TypeRegistry\"\n"
	funcDef     = "\nfunc GetRegistry() (registry TypeRegistry.Registry) {\n"
	funcBottom  = "\n    return\n" +
		"}\n"
)

/* Default file contents for resetting. */
var (
	defaultFile = `package main

import "github.com/j7mbo/goij/src/TypeRegistry"

func GetRegistry() (registry TypeRegistry.Registry) {
    return
}

`
)

/* An object responsible for writing packageData structs to a file given the template above. */
type AutoGeneratedRegistryWriter struct{}

/* Write the contents of defaultFile to the file. */
func (*AutoGeneratedRegistryWriter) WriteDefaultFile(filePath string) {
	file, err := os.Create(filePath)

	defer func() { _ = file.Close() }()

	if err != nil {
		panic(fmt.Sprintf("Unable to write empty type structRegistry to file: %s, error: %s", filePath, err.Error()))
	}

	_, err = file.WriteString(defaultFile)

	if err != nil {
		panic(fmt.Sprintf("Unable to write empty type structRegistry to file: %s, error: %s", filePath, err.Error()))
	}
}

/* Write the results of []packageData to a readable to file. Could've used the AST for this, but I'm lazy... */
func (*AutoGeneratedRegistryWriter) WriteAutoGeneratedDataToFile(packageDataList []packageData, filePath string) {
	dir, _ := filepath.Split(filePath)

	importPath, err := retrieveImportPath(dir)

	if err != nil {
		/* We can't update the package name, let the user know they need to do this themselves... */
		fmt.Println(fmt.Sprintf("[Info] - Don't forget to set the package name in the generated structRegistry file."))
	} else {
		/*
			Guess the import path: This could be wrong if the structRegistry was generated into the project directory (main).
			There's no way I can see to reliably figure out if the root of the project was the one chosen.
		*/
		importName := strings.Split(importPath, "/")[len(strings.Split(importPath, "/"))-1]

		fileTop = fmt.Sprintf("package %s\n", importName)
	}

	file, err := os.Create(filePath)

	defer func() { _ = file.Close() }()

	if err != nil {
		panic(fmt.Sprintf("Unable to write auto generated type structRegistry to file: %s, error: %s", filePath, err.Error()))
	}

	for _, packageData := range packageDataList {
		/* May have 0 structs, but factories can return interfaces... */
		if len(packageData.Structs) == 0 && len(packageData.Interfaces) == 0 {
			continue
		}

		/* Alias for the import so multiple of the same package name will not be an issue. */
		alias := generateRandomString(8)

		fileImports += fmt.Sprintf("import %s \"%s\"\n", alias, packageData.ImportPath)

		for _, structName := range packageData.Structs {
			mapKey := fmt.Sprintf("%s.%s", packageData.ImportPath, structName)
			mapType := fmt.Sprintf("%s.%s", alias, structName)

			funcDef += fmt.Sprintf(
				"    registry.RegistryStructs = append(registry.RegistryStructs, TypeRegistry.RegistryStruct{ Name: \"%s\", Implementation: %s{}})\n",
				mapKey, mapType,
			)
		}

		for _, interfaceName := range packageData.Interfaces {
			mapKey := fmt.Sprintf("%s.%s", packageData.ImportPath, interfaceName)
			mapType := fmt.Sprintf("%s.%s", alias, interfaceName)

			funcDef += fmt.Sprintf(
				"    registry.RegistryInterfaces = append(registry.RegistryInterfaces, TypeRegistry.RegistryInterface{ Name: \"%s\", Implementation: (*%s)(nil)})\n",
				mapKey, mapType,
			)
		}

		if len(packageData.Factories) == 0 {
			continue
		}

		existingFactories := make(map[string]string)

		for _, factory := range packageData.Factories {
			mapKey := fmt.Sprintf("%s.%s", packageData.ImportPath, factory.ReturnType)
			mapType := fmt.Sprintf("%s.%s", alias, factory.MethodName)

			if _, exists := existingFactories[mapKey]; !exists {
				/* Adds this only once, then later we replace the escaped %s with the individual factories. */
				existingFactories[mapKey] = fmt.Sprintf(
					"    registry.RegistryFactories = append(registry.RegistryFactories, TypeRegistry.RegistryFactory{ Name: \"%s\", Implementations: []interface{}{ <TYPE> }})\n",
					mapKey,
				)
			}

			existingFactories[mapKey] = strings.Replace(existingFactories[mapKey], "<TYPE>", mapType+", <TYPE>", 1)
		}

		for _, factoryString := range existingFactories {
			funcDef += factoryString
		}

		funcDef = strings.Replace(funcDef, ", <TYPE>", "", -1)
	}

	fileContents := fileTop + fileImports + funcDef + funcBottom

	_ = template.Must(template.New("").Parse(fileContents)).Execute(file, struct{}{})
}

/* Generate a pseudorandom alphanumeric string of a fixed length. */
func generateRandomString(length int) string {
	rand.Seed(time.Now().UnixNano())

	var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

	b := make([]rune, length)

	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}

	return string(b)
}

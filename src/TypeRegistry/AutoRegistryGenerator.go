package TypeRegistry

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"strings"
)

/* An object capable of immense wizardry. */
type AutoRegistryGenerator struct {
	registryWriter *AutoGeneratedRegistryWriter
}

/* Initialise a new instance of AutoRegistryGenerator. */
func NewAutoRegistryGenerator(registryWriter AutoGeneratedRegistryWriter) AutoRegistryGenerator {
	return AutoRegistryGenerator{registryWriter: &registryWriter}
}

/*
Generate a registry of all types within the application, given a root directory to recurse.

The file argument is the file to write the registry to.
The dirPath option is the root directory to start recursing through.
The ignoreDirs option is to pass in a list of directories to ignore such as vendor/.
*/
func (g *AutoRegistryGenerator) Generate(file string, dirPath string, ignoreDirs ...string) {
	dirPaths := findDirPathsRecursively(dirPath, ignoreDirs)

	var packageDataList []packageData

	for _, dirPath := range dirPaths {
		for _, pckData := range g.retrievePackageInformation(dirPath) {
			packageDataList = append(packageDataList, pckData)
		}
	}

	g.registryWriter.WriteAutoGeneratedDataToFile(packageDataList, file)
}

/* Reset the generated file to defaults. */
func (g *AutoRegistryGenerator) Reset(filePath string) {
	if !fileExists(filePath) {
		panic(fmt.Sprintf("Registry file: '%s' does not exist or does not have correct permissions", filePath))
	}

	// @todo Use AST to ensure that this is a structRegistry file and not some random file we're overwriting!

	g.registryWriter.WriteDefaultFile(filePath)
}

/* Fine all directory paths recursively given a top-level directory. */
func findDirPathsRecursively(dirPath string, ignoreDirs []string) (dirs []string) {
	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		for _, ignoreDir := range ignoreDirs {
			if strings.HasPrefix(path, ignoreDir) {
				return nil
			}
		}

		if info.IsDir() {
			dirs = append(dirs, path)
		}

		return nil
	})

	if err != nil {
		panic("Unable to automatically register types due to a directory reading error: " + err.Error())
	}

	return
}

/* Simple struct to group a package's name with it's import path. */
type packageData struct {
	/* The name of the package, like "TypeRegistry". */
	PackageName string

	/* The fully qualified import path, like "github.com/j7mbo/goij/src/TypeRegistry". */
	ImportPath string

	/* A list of all publicly available structs within this package. */
	Structs []string

	/* A list of all publicly available interfaces within this package. */
	Interfaces []string

	/* A list of all factory functions available within this package. */
	Factories []factory
}

type factory struct {
	/* Factory method name. */
	MethodName string

	/* Return object within this package. */
	ReturnType string
}

func (g *AutoRegistryGenerator) retrievePackageInformation(dirPath string) (packageDataList []packageData) {
	set := token.NewFileSet()

	packages, err := parser.ParseDir(set, dirPath, nil, 0)

	if err != nil {
		panic(fmt.Sprintf("Could not retrieve packages for path: '%s', error: '%s'", dirPath, err.Error()))
	}

	for _, pkg := range packages {
		if len(pkg.Files) == 0 {
			break
		}

		/* Ignore package main for now. */
		if pkg.Name == "main" {
			continue
		}

		/* All files in the directory will have the same import path, so we only need the first. */
		firstFilePath := reflect.ValueOf(pkg.Files).MapKeys()[0].String()

		dir, _ := filepath.Split(firstFilePath)

		importPath, err := retrieveImportPath(dir)

		if err != nil {
			fmt.Println(fmt.Sprintf("[Warning] - Unable to retrieve import path for: '%s', ignoring...", importPath))

			continue
		}

		structs, interfaces, factories := g.parseTypesFromPackage(pkg)

		packageDataList = append(packageDataList, packageData{
			PackageName: pkg.Name,
			ImportPath:  importPath,
			Structs:     structs,
			Interfaces:  interfaces,
			Factories:   factories,
		})
	}

	return packageDataList
}

/* Use the AST to parse out certain types from a given package. */
func (g *AutoRegistryGenerator) parseTypesFromPackage(pkg *ast.Package) (
	structs []string, interfaces []string, factories []factory,
) {
	for filePath, file := range pkg.Files {
		/* Ignore test files also (by convention ending in _test). */
		if strings.HasSuffix(filePath, "_test.go") {
			continue
		}

		/*
			Ignore anything from golang.org.. there's a lot of /x/sys/unix stuff we don't want for example, files that
			do not match the target system (windows.go) - currently can't see a way to use the AST to detect whether or
			not these files should be parsed, so let's ignore them for now.
		*/
		if strings.Contains(filePath, "golang.org/") {
			continue
		}

		for _, fileDeclarations := range file.Decls {
			if genDecl, isGenDecl := fileDeclarations.(*ast.GenDecl); isGenDecl {
				for _, fileDeclaration := range genDecl.Specs {
					if theType, isTypeSpec := fileDeclaration.(*ast.TypeSpec); isTypeSpec {
						if !theType.Name.IsExported() {
							continue
						}

						/* Structs */
						if _, isStruct := theType.Type.(*ast.StructType); isStruct {
							structs = append(structs, theType.Name.String())
						}

						/* Interfaces */
						if _, isInterface := theType.Type.(*ast.InterfaceType); isInterface {
							interfaces = append(interfaces, theType.Name.String())
						}
					}
				}
			}

			if funcDecl, isFuncDecl := fileDeclarations.(*ast.FuncDecl); isFuncDecl {
				/* Factory functions must start with "New". Ignore private unexported factory functions. */
				if !strings.HasPrefix(funcDecl.Name.String(), "New") {
					continue
				}

				/* There are no return values, so it's not a factory! */
				if funcDecl.Type.Results == nil {
					continue
				}

				/* Ignore all those New methods that are on pointer receivers... they're not factory functions. */
				if funcDecl.Recv != nil {
					continue
				}

				/* "New" convention function found, but no return type? Ignore it... */
				if len(funcDecl.Type.Results.List) == 0 {
					continue
				}

				/* If the method returns a type, it's a factory! Naively assumes a single return type in pos [0]. */
				returnType := funcDecl.Type.Results.List[0].Type

				var returnTypeName string

				/* For future, interfaces: returnType.(*ast.Ident).Obj.Decl.(*ast.TypeSpec).Type.(*ast.InterfaceType) */
				if structOrInterfaceReturntype, isStructOrInterface := returnType.(*ast.Ident); isStructOrInterface {
					returnTypeName = structOrInterfaceReturntype.Name
				}

				if pointerReturnType, isPointerReturnType := returnType.(*ast.StarExpr); isPointerReturnType {
					if identType, isIdentType := pointerReturnType.X.(*ast.Ident); isIdentType {
						returnTypeName = identType.Name
					} else {
						/* It  could be an *ast.SelectorExpr - not sure why I'd want this yet... */
						continue
					}
				}

				// @todo what if this factory returns an object from a completely separate package? Is it added to the
				// @todo registry as if it was for the current package??

				factories = append(
					factories,
					factory{
						MethodName: funcDecl.Name.Name,
						ReturnType: returnTypeName,
					},
				)
			}
		}
	}

	return
}

/*
Dear programming gods, please forgive me for what I am about to do.

Note: If there are no go files in this directory go list will send "can't load package, unknown import path" to stderr.
*/
func retrieveImportPath(dirPath string) (string, error) {
	goPath, err := exec.LookPath("go")

	if err != nil {
		return "", errors.New("Unable to retrieve go executable path , error:" + err.Error())
	}

	cmd := exec.Command(goPath, "list")
	cmd.Dir = dirPath
	bytes, err := cmd.Output()

	if err != nil {
		return "", errors.New(
			"Unable to retrieve import path for directory, are you using go modules? Error: " + err.Error(),
		)
	}

	return strings.TrimSuffix(string(bytes), "\n"), nil
}

/* Reports whether or not the given file exists. */
func fileExists(filePath string) bool {
	_, err := os.Stat(filePath)

	return !os.IsNotExist(err)
}

package TypeRegistry

import (
	"fmt"
	"reflect"
	"strings"
)

/* A registry containing all structs, and their package names, in the application. */
type TypeRegistry struct {
	/* Only contains types registered. */
	registry map[string][]interface{}
	/* Contains any cached objects we want to draw from. */
	builtObjs map[string][]interface{}
}

/* Terrible wizardry. Only run this after having run ./bin/gen. */
func NewFromGeneratedRegistry() *TypeRegistry {
	return &TypeRegistry{registry: GetAutoGeneratedRegistry(), builtObjs: make(map[string][]interface{})}
}

/* Returns an empty TypeRegistry for the heathens that don't like magic. */
func New() *TypeRegistry {
	return &TypeRegistry{registry: make(map[string][]interface{}), builtObjs: make(map[string][]interface{})}
}

func (r *TypeRegistry) AddBuildObject(obj interface{}) {
	var typeName string

	/* If pointer passed in, derefence and register type name. */
	if reflect.TypeOf(obj).Kind() == reflect.Ptr {
		// typeName = fmt.Sprintf("%s.%s", reflect.TypeOf(obj).Elem().PkgPath(), reflect.TypeOf(obj).Elem().Name())
		typeName = reflect.TypeOf(obj).Elem().String()
	} else {
		panic(fmt.Sprintf("You must pass a pointer to type: %T when registering in the injector", obj))
		// typeName = fmt.Sprintf("%s.%s", reflect.TypeOf(obj).PkgPath(), reflect.TypeOf(obj).Name())
	}

	/* If no type has been registered yet, create an initial array and add to the registry. */
	if _, exists := r.builtObjs[typeName]; !exists {
		r.builtObjs[typeName] = make([]interface{}, 0)
		r.builtObjs[typeName] = append(r.builtObjs[typeName], &obj)

		return
	}

	typeArray := r.builtObjs[typeName]

	/* Name already exists for this type - if type already exists in registry, overwrite it. */
	for key, existingObject := range typeArray {
		if reflect.ValueOf(existingObject).Type() == reflect.ValueOf(obj).Type() {
			typeArray[key] = obj

			return
		}
	}

	/* Combination of Package.StructName exists, but this type is not registered - append it. */
	typeArray = append(typeArray, obj)
}

/*
Add a type to the registry named as a combination of "Package.StructName". As this combination can exist across multiple
directories in the codebase, a sub array for Package.StructName contains all possible types which must be resolved at
runtime.

This type MUST be a pointer or else this method will panic.
*/
func (r *TypeRegistry) AddType(obj interface{}) {
	var typeName string

	/* If pointer passed in, derefence and register type name. */
	if reflect.TypeOf(obj).Kind() == reflect.Ptr {
		// typeName = fmt.Sprintf("%s.%s", reflect.TypeOf(obj).Elem().PkgPath(), reflect.TypeOf(obj).Elem().Name())
		typeName = reflect.TypeOf(obj).Elem().String()
	} else {
		panic(fmt.Sprintf("You must pass a pointer to type: %T when registering in the injector", obj))
		// typeName = fmt.Sprintf("%s.%s", reflect.TypeOf(obj).PkgPath(), reflect.TypeOf(obj).Name())
	}

	/* If no type has been registered yet, create an initial array and add to the registry. */
	if _, exists := r.registry[typeName]; !exists {
		r.registry[typeName] = make([]interface{}, 0)
		r.registry[typeName] = append(r.registry[typeName], &obj)

		return
	}

	typeArray := r.registry[typeName]

	/* Name already exists for this type - if type already exists in registry, overwrite it. */
	for key, existingObject := range typeArray {
		if reflect.ValueOf(existingObject).Type() == reflect.ValueOf(obj).Type() {
			typeArray[key] = obj

			return
		}
	}

	/* Combination of Package.StructName exists, but this type is not registered - append it. */
	typeArray = append(typeArray, obj)
}

/* Retrieve the whole registry. */
func (r *TypeRegistry) GetRegistry() map[string][]interface{} {
	return r.registry
}

/* Retrieve the whole built objects. */
func (r *TypeRegistry) GetBuiltObjects() map[string][]interface{} {
	return r.builtObjs
}

/* Given a key, return the first found element.. given an int as a second parameter, return that element instead. */
func (r *TypeRegistry) FindTypeByName(name string, option ...int) interface{} {
	if types, exists := r.registry[name]; exists {
		if len(option) > 0 && len(types) >= option[0] {
			return types[option[0]]
		}

		for _, theType := range types {
			return theType
		}
	}

	return nil
}

/* Given a struct field (when recursing around a struct's fields with reflect); find the type in the registry. */
func (r *TypeRegistry) FindTypeByStructField(objType reflect.StructField) interface{} {
	theType := objType.Type
	typeKey := strings.Replace(theType.String(), "*", "", -1) // @todo handle pointers properly??
	//originalTypeKey := theType.String()

	if registryTypes, found := r.registry[typeKey]; found {
		for _, registryType := range registryTypes {
			// Only need this if it's a pointer --v
			if reflect.TypeOf(registryType).Elem() == theType.Elem() {
				return registryType
			}
		}
	}

	return nil
}

/* Given a reflect value (when recursing around a struct's fields with reflect); find the type in the registry. */
func (r *TypeRegistry) FindTypeByValue(objType reflect.Value) interface{} {
	theType := objType.Type()

	typeKey := strings.Replace(theType.String(), "*", "", -1) // @todo handle pointers properly??
	// originalTypeKey := theType.String()

	if registryTypes, found := r.registry[typeKey]; found {
		for _, registryType := range registryTypes {
			// Only need this if it's a pointer --v
			if objType.Kind() == reflect.Ptr {
				if reflect.TypeOf(registryType).Elem() == theType.Elem() {
					return registryType
				}
			} else {
				if reflect.TypeOf(registryType).Elem() == theType {
					return registryType
				}
			}
		}
	}

	return nil
}

/* Given a reflect value (when recursing around a struct's fields with reflect); find the object already stored. */
func (r *TypeRegistry) FindBuiltObjectByValue(objType reflect.Value) interface{} {
	theType := objType.Type()

	typeKey := strings.Replace(theType.String(), "*", "", -1) // @todo handle pointers properly??
	// originalTypeKey := theType.String()

	if builtObjects, found := r.builtObjs[typeKey]; found {
		for _, builtObject := range builtObjects {
			// Only need this if it's a pointer --v
			if objType.Kind() == reflect.Ptr {
				if reflect.TypeOf(reflect.ValueOf(builtObject).Elem().Elem().Elem().Interface()) == theType.Elem() {
					return builtObject
				}
			} else {
				if reflect.TypeOf(builtObject).Elem() == theType {
					return builtObject
				}
			}
		}
	}

	return nil
}

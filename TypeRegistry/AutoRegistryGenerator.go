package TypeRegistry

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"runtime"
	"strings"
)

/* The file where the registry will be written to. */
const autoGeneratedRegistryFile = "TypeRegistry/AutoGeneratedRegistry.go"

/* An object capable of immense wizardry. */
type AutoRegistryGenerator struct {
	registryWriter *AutoGeneratedRegistryWriter
}

/* Initialise a new instance of AutoRegistryGenerator. */
func NewAutoRegistryGenerator(registryWriter AutoGeneratedRegistryWriter) AutoRegistryGenerator {
	return AutoRegistryGenerator{registryWriter: &registryWriter}
}

/*
Generate a registry of all types within the application, given a root directory to recurse.

The dirPath option is the root directory to start recursing through.
The ignoreDirs option is to pass in a list of directories to ignore such as vendor/.
*/
func (g *AutoRegistryGenerator) Generate(dirPath string, ignoreDirs ...string) {
	dirPaths := g.findDirPathsRecursively(dirPath, ignoreDirs)

	var packageDataList []PackageData

	for _, dirPath := range dirPaths {
		for _, pckData := range g.retrievePackageInformation(dirPath) {
			packageDataList = append(packageDataList, pckData)
		}
	}

	g.registryWriter.WriteAutoGeneratedDataToFile(packageDataList, autoGeneratedRegistryFile)
}

/* Reset the generated file to defaults. */
func (g *AutoRegistryGenerator) Reset() {
	g.registryWriter.WriteDefaultFile(autoGeneratedRegistryFile)
}

/* Fine all directory paths recursively given a top-level directory. */
func (g *AutoRegistryGenerator) findDirPathsRecursively(dirPath string, ignoreDirs []string) (dirs []string) {
	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		for _, ignoreDir := range ignoreDirs {
			if path == ignoreDir {
				return nil
			}
		}

		if info.IsDir() {
			dirs = append(dirs, path)
		}

		return nil
	})

	if err != nil {
		panic("Unable to automatically register types due to a directory reading error: " + err.Error())
	}

	return dirs
}

/* Simple struct to group a package's name with it's import path. */
type PackageData struct {
	/* The name of the package, like "TypeRegistry" */
	PackageName string

	/* The fully qualified import path, like "github.com/j7mbo/Injector/registry". */
	ImportPath string

	/* A list of all publicly available structs within this package. */
	Structs []string
}

func (g *AutoRegistryGenerator) retrievePackageInformation(dirPath string) (packageDataList []PackageData) {
	set := token.NewFileSet()

	packages, err := parser.ParseDir(set, dirPath, nil, 0)

	if err != nil {
		panic(fmt.Sprintf("Could not retrieve packages for path: '%s', error: '%s'", dirPath, err.Error()))
	}

	for _, pkg := range packages {
		if len(pkg.Files) == 0 {
			break
		}

		/* All files in the directory will have the same import path, so we only need the first. */
		firstFilePath := reflect.ValueOf(pkg.Files).MapKeys()[0].String()

		dir, _ := filepath.Split(firstFilePath)

		importPath := g.retrieveImportPath(dir)

		/* Ignore the current import path of this file as we don't want these in the registry. */
		_, currentFile, _, _ := runtime.Caller(0)
		currentDir := filepath.Dir(currentFile)

		/* Also ignore package main for now (for testing injector usage in this repo). */
		if g.retrieveImportPath(currentDir) == importPath || pkg.Name == "main" {
			continue
		}

		packageDataList = append(packageDataList, PackageData{
			PackageName: pkg.Name,
			ImportPath:  importPath,
			Structs:     g.parseTypesFromPackage(pkg),
		})
	}

	return packageDataList
}

/* Dear programming gods, please forgive me for what I am about to do. */
func (g *AutoRegistryGenerator) retrieveImportPath(dirPath string) string {
	cmd := exec.Command("/usr/local/go/bin/go", "list")
	cmd.Dir = dirPath
	bytes, err := cmd.Output()

	if err != nil {
		panic("Unable to retrieve import path for directory, are you using go modules? Error: " + err.Error())
	}

	return strings.TrimSuffix(string(bytes), "\n")
}

/* Use the AST to parse out certain types from a given package. */
func (g *AutoRegistryGenerator) parseTypesFromPackage(pkg *ast.Package) (structs []string) {
	for _, file := range pkg.Files {
		for _, fileDeclarations := range file.Decls {
			if genDecl, isGenDecl := fileDeclarations.(*ast.GenDecl); isGenDecl {
				for _, fileDeclaration := range genDecl.Specs {
					if theType, isTypeSpec := fileDeclaration.(*ast.TypeSpec); isTypeSpec {
						if !theType.Name.IsExported() {
							continue
						}

						/* Structs */
						if _, isStruct := theType.Type.(*ast.StructType); isStruct {
							structs = append(structs, theType.Name.String())
						}
					}
				}
			}
		}
	}

	return structs
}
